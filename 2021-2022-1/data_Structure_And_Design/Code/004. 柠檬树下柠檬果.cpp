/*
柠檬树上柠檬果，柠檬树下你和我。 
柠檬树前做游戏，欢乐多又多。
在学校里，碰巧就长了这样的一棵柠檬树。受到校内理工气息的影响，这棵柠檬树长成了一棵深度为h的满二叉树的样子，这棵树一共有2h-1个叶子节点。
每年到了收获季节，这棵柠檬树的顶点都会结出2h-1个柠檬果，这些柠檬果会依次从顶点一层一层的滑落到叶子节点。柠檬果在每一个节点向下滑落时，都会往左下或者往右下滑落，直到落到叶子节点上。初始状态时，所有的节点都让果子向左下滑落。每当一个节点有果子经过后，就会改变其让果子滑落的方向。比如一个果子在经过某一个节点时向左滑落了，那么下一次当再有果子经过这个节点的时候，就会在这个节点向右滑落。
现在这2h-1个柠檬果会依次从顶点开始向下滑落，但是Roark已经等不及所有柠檬果都落下来了，他想提前知道第n个柠檬果会落到哪个叶子节点上。
Input
本题有多组用例（用例数量不超过1000）.
每组用例包含两个整数 h (1≤h≤20)和 n (1≤n≤2h-1)，分别标是树的高度和Roark想知道位置的果子编号。
读入到文件末尾。
Output
对每组用例，输出一行"Case #x: y"，其中x表示用例的序号，y表示你的答案。
*/

#include <bits/stdc++.h>

int main(){
	int h, num, Case = 0;
	while(scanf("%d", &h) != EOF){
		scanf("%d", &num);
		int ans = 0, length = 2;
		for(int i = 1; i < h - 1; i++)
			length *= 2;
		for(int i = 1; i < h; i++){
			if(num % 2 == 0){
				ans += length / 2;
				num /= 2;
			}else
				num = (num / 2) + 1;
			length /= 2;
		}
		printf("Case #%d: %d\n", ++Case, ans + 1);
	}
}
